
##  base class for python-based engines

from kkplot.kkengines.base import kkplot_engine as kkplot_engine
from kkplot.kkengines.base import kkplot_plotmethod as kkplot_plotmethod
from kkplot.kkplot_dviplot import kkplot_dviplot as kkplot_dviplot

from kkplot.kkutils.log import *
from kkplot.kkutils import writer as kkplot_writer

import sys
import time

KKPLOT_RUN_USER_CODE = '''
    ## run user code
    if user_code_available :
        user_code.customize_figure( kkfigures)
'''

KKPLOT_TIMEDELTA = '''
class kkplot_timedelta( object) :
    def __init__( self, _timedelta) :
        self._td = _timedelta
        
    @property
    def seconds( self) :
        return float( self._td.days * 86400 + self._td.seconds)
    @property
    def minutes( self) :
        return float( self._td.days * 1440 + self._td.seconds//60)
    @property
    def hours( self) :
        return float( self._td.days * 24 + self._td.seconds//3600)
    @property
    def days( self) :
        return float( self._td.days)
'''

KKPLOT_TIMEPERIOD = '''
class kkplot_timeperiod( object) :
    def __init__( self, _timedelta) :
        self._td = kkplot_timedelta( _timedelta)

    @property
    def seconds( self) :
        return self._td.seconds + 1.0
    @property
    def minutes( self) :
        return self._td.minutes + 1.0
    @property
    def hours( self) :
        return self._td.hours + 1.0
    @property
    def days( self) :
        return self._td.days + 1.0
'''

class kkplot_engine_base_python( kkplot_engine) :
    def  __init__( self, _name, _conf=None, _dviplot=None) :
        super( kkplot_engine_base_python, self).__init__( _name, _conf, _dviplot)
        self.wrtr = None

    def new_writer( self) :
        if self.wrtr is None :
            self.wrtr = kkplot_writer( _stream=None, _mode='python')
        return  self.wrtr

    @property
    def writer( self) :
        return self.wrtr
    @property
    def suffix( self) :
        return 'py'

    def python_plots_graphmethodcalls( self, _graphmethods) :
        w = self.writer.iappendnl

        w( 0, '')
        w( 1, 'graphresults = dict()')
        w( 1, 'kkdataframes = dict()')

        seriesopts = dict( time=', parse_dates=["time"], index_col=1, keep_date_col=True', space='', non='')
        delim = self._conf.tmpdata_column_delim
        ## add graphs
        for graphmethod in _graphmethods :
            graphid = graphmethod.graph.graphid
            if self.dviplot.series_exists( graphid) :
                w( 1, 'try :')
                w( 2, 'kkdataframes["%s"] = pandas.read_csv( "%s", ' % ( graphid, self.dviplot.datapool_filename( graphid)) +
                    'header=0, na_values=["na"], sep="%s"' % ( delim) + seriesopts[graphmethod.graph.domainkind] + ')')
                w( 1, 'except :')
                w( 2, r'sys.stderr.write( "failed to open datafile  [datafile=%s]\n")' % ( self.dviplot.datapool_filename( graphid)))

            w( 1, 'graphresults["%s"] = \\' % ( graphmethod.graph.graphresult))
            w( 2, graphmethod.methodcall)

    def python_preamble( self) :
        self.writer.appendnl( '# vim: ft=python')
        self.writer.appendnl( '## generated by kkplot on %s\n' % ( time.strftime( '%Y, %b. %d %H:%M')))
        self.writer.appendnl( 'import datetime as datetime')
        self.writer.appendnl( 'import pandas as pandas')
        self.writer.appendnl( 'import numpy as numpy')
        self.writer.newline()

        self._import_user_module()

    def python_addhelpers( self, _helpers=None) :
        H = dict()
        H['timedelta'] = KKPLOT_TIMEDELTA
        H['timeperiod'] = KKPLOT_TIMEPERIOD
        helpers = H if _helpers is None else _helpers
        for helper in helpers :
            self.writer.appendnl( H[helper])
        self.writer.newline()

    def python_postamble( self) :
        self.writer.newline()

    def _import_user_module( self) :
        import os
        import sys

        o = self.dviplot.outputfile.strip()
        o = o.replace( '/', os.sep)
        o = o.replace( '\\', os.sep)
        o_path, o_file = os.path.split( o)
        if not o_path == '' :
            self.writer.iappendnl( 0, 'import sys')
            self.writer.iappendnl( 0, 'sys.path.insert( 0, "%s")' % ( os.path.abspath( o_path)))
        module_name = self._canonicalize_name( o_file)
        self.writer.iappendnl( 0, 'user_code_available = True')
        self.writer.iappendnl( 0, 'try:')
        self.writer.iappendnl( 1, 'import %s as user_code' % ( module_name))
        self.writer.iappendnl( 1, 'print( "seeing user changes, using them")')
        self.writer.iappendnl( 0, 'except ImportError : #as import_error :')
        self.writer.iappendnl( 1, '## no user code')
        self.writer.iappendnl( 1, '#print( "ImportError: %s" % ( import_error))')
        self.writer.iappendnl( 1, 'user_code_available = False')
        self.writer.iappendnl( 0, '')

    def _canonicalize_name( self, _name) :
        validchars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789'
        canonicalized_name = ''
        for c in _name :
            if not c in validchars :
                canonicalized_name += '_'
            else :
                canonicalized_name += c

        return canonicalized_name

    def _make_args( self, _commas, **_kwargs) :
        args = ', '.join([ '%s=%s' % ( k, self._stringify( v)) for ( k, v) in zip( _kwargs.keys(), _kwargs.values()) if v is not None])
        if args == '' :
            pass
        elif _commas == 'l' :
            args = ', %s' % ( args)
        elif _commas == 'r' :
            args += ', '
        elif _commas == 'lr' or _commas == 'rl' :
            args = ', %s, ' % ( args)
        return args

    def _make_labels( self, _columns, _graph) :
        lbl = lambda c : _graph.get_property( 'label.%s' % ( c))
        labels = '%s' % ( ','.join( \
            [ '"%s":%s' % ( c, '"_nolabel"' if lbl(c) is None else self._stringify( lbl(c))) for c in _columns]))
        return labels


    def _stringify( self, _value) :
        if _value is None :
            return 'None'
        elif type( _value) == str :
            return '"%s"' % ( _value)
        else :
            return '%s' % ( str( _value))

    def _toggle( self, _value) :
        kklog_debug( '%s->%s' % ( _value, not _value))
        if _value :
            return not _value
        return _value

